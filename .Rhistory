### Output: a random preference ordering of X, size(X) is most preferred and 1 is least preferred
prefOrder <- function(x) {
runif(n = x, min = 0, max = 100) #return a random preference ordering
}
### Function: Trial
### Inputs: N, the number of candidates that can be voted for
###         X, the number of voters
### Output: Random perference orderings for X voters, voting for N candidates
trial <- function(n, x) {
base <- c(1:n) #Create a vector with values from 1 to n
voters <- matrix(0, nrow = x, ncol = n, byrow = TRUE)
for (row in 1:nrow(voters)) {
voters[row,] = prefOrder(base)
}
voters
}
### Function: findBordaCount
### Inputs: LISTY, a list of voters and their preferences
### Output: The Borda Counts for each candidate
findBordaCount <- function(matrixy) {
len = ncol(matrixy)
voteCount <- integer(len) #make a vector to keep track of vote totals for each candidate
numVoters <- nrow(matrixy)
for (i in 1:numVoters) {
matrixy[i,] = rank(matrixy[i,])
for (j in 1:len) {
voteCount[j] = voteCount[j] + matrixy[i,j] #add the current voter's points
}
}
voteCount #return the vector containing each candidates point count
}
### Function: bordaCountWinner
### returns the Borda Count Winner
bordaCountWinner <- function(matrixy) {
which.max(findBordaCount(matrixy)) #returns a randomly chosen winner if there is a tie
}
### Function: findPluralityWinner
### Inputs: LISTY, a list of voters and their preferences
### Output: The Plurality winner/winners (if there is a tie)
findPluralityWinner <- function(matrixy) {
len = nrow(matrixy)
f = ncol(matrixy)
winnerVec <- integer(f) #create a vector keeping track of how many votes each candidate has
for (i in 1:len) {
maxIndex = which.max(matrixy[i,])
winnerVec[maxIndex] = winnerVec[maxIndex] + 1 #add 1 to the voter's top candidate
}
## winnerVec
which.max(winnerVec)
# which(winnerVec == max(winnerVec)) #returns the indices of the candidates with the most votes
}
isWinnerSame <- function(n,x)
{
myTrial <- trial(n,x)
findPluralityWinner(myTrial) == bordaCountWinner(myTrial)
}
buildMatrix <- function(n,x) {
mat <- matrix(0, nrow = n, ncol = x + 1)
vec <- 10^(0:x)
for (i in 1:n) {
t = 1
for (j in vec) {
test <-  t(replicate(10,isWinnerSame(i,j)))
mat[i, t] = mean(test)
t = t + 1
}
}
mat
}
b <- buildMatrix(6,2)
b
b <- buildMatrix(6,3)
rank(b)
b
b
buildMatrix <- function(n,x) {
mat <- matrix(0, nrow = n, ncol = x + 1)
vec <- 10^(0:x)
for (i in 1:n) {
t = 1
for (j in vec) {
test <-  t(replicate(1000,isWinnerSame(i,j)))
mat[i, t] = mean(test)
t = t + 1
}
}
mat
}
b <- buildMatrix(6,3)
b
findPluralityWinner <- function(matrixy) {
which.max(findPluralityCount(matrixy))
}
### Function: findPluralityWinner
### Inputs: LISTY, a list of voters and their preferences
### Output: The Plurality winner/winners (if there is a tie)
findPluralityCount <- function(matrixy) {
len = nrow(matrixy)
f = ncol(matrixy)
winnerVec <- integer(f) #create a vector keeping track of how many votes each candidate has
for (i in 1:len) {
maxIndex = which.max(matrixy[i,])
winnerVec[maxIndex] = winnerVec[maxIndex] + 1 #add 1 to the voter's top candidate
}
winnerVec
##which.max(winnerVec)
# which(winnerVec == max(winnerVec)) #returns the indices of the candidates with the most votes
}
findPluralityWinner <- function(matrixy) {
which.max(findPluralityCount(matrixy))
}
makeProbVec <- function(matrixy,func) {
vec <- func(matrixy)
}
makeProbVec(trial(3,5), findBordaCount)
makeProbVec <- function(matrixy,func) {
vec <- func(matrixy)
vec
}
makeProbVec(trial(3,5), findBordaCount)
makeProbVec(trial(3,5), findBordaCount)
makeProbVec <- function(matrixy,func) {
print func
vec <- func(matrixy)
vec
}
makeProbVec <- function(matrixy,func) {
vec <- func(matrixy)
prob <- c()
len <- length(vec)
summy <- sum(vec)
for (i in 1:len) {
prob[i] = vec[i]/summy
}
prob
}
makeProbVec(trial(3,5), findBordaCount)
makeProbVec(trial(3,5), findBordaCount)
makeProbVec(trial(3,5), findBordaCount)
makeProbVec(trial(3,5), findBordaCount)
makeProbVec(trial(3,5), findBordaCount)
makeProbVec(trial(3,5), findPluralityCount)
makeProbVec(trial(3,5), findPluralityCount)
makeProbVec(trial(3,5), findPluralityCount)
makeProbVec(trial(3,5), findPluralityCount)
makeProbVec(trial(3,5), findPluralityCount)
makeProbVec(trial(3,5), findPluralityCount)
makeProbVec(trial(3,5), findPluralityCount)
makeProbVec(trial(3,5), findPluralityCount)
makeProbVec(trial(3,5), findPluralityCount)
makeProbVec(trial(3,5), findPluralityCount)
makeProbVec(trial(3,5), findPluralityCount)
makeProbVec(trial(3,5), findPluralityCount)
makeProbVec(trial(3,5), findPluralityCount)
makeProbVec(trial(3,20), findPluralityCount)
makeProbVec(trial(3,20), findPluralityCount)
makeProbVec(trial(3,150), findPluralityCount)
makeProbVec(trial(3,150), findPluralityCount)
makeProbVec(trial(3,150), findPluralityCount)
makeProbVec(trial(3,150), findPluralityCount)
makeProbVec(trial(3,450), findPluralityCount)
makeProbVec(trial(3,10000), findPluralityCount)
makeProbVec(trial(3,10000), findPluralityCount)
makeProbVec(trial(3,10000), findPluralityCount)
makeProbVec(trial(3,100000), findPluralityCount)
makeProbVec(trial(3,100000), findPluralityCount)
makeProbVec(trial(3,100000), findPluralityCount)
makeProbVec <- function(matrixy,func) {
vec <- func(matrixy)
prob <- c()
len <- length(vec)
summy <- sum(vec)
for (i in 1:len) {
prob[i] = vec[i]/summy
}
prob
for (i in 1:len) {
prob[i] = rnorm(1,mean = prob[i], sd = .01)
}
}
makeProbVec(trial(3,100000), findPluralityCount)
prob
makeProbVec <- function(matrixy,func) {
vec <- func(matrixy)
prob <- c()
len <- length(vec)
summy <- sum(vec)
for (i in 1:len) {
prob[i] = vec[i]/summy
}
for (i in 1:len) {
prob[i] = rnorm(1,mean = prob[i], sd = .01)
}
prob
}
prob
makeProbVec(trial(3,100000), findPluralityCount)
sum(makeProbVec(trial(3,100000), findPluralityCount))
makeProbVec <- function(matrixy,func) {
vec <- func(matrixy)
prob <- c()
len <- length(vec)
summy <- sum(vec)
for (i in 1:len) {
prob[i] = vec[i]/summy
prob[i] = rnorm(1,mean = prob[i], sd = .02)
}
prob
}
sum(makeProbVec(trial(3,100000), findPluralityCount))
sum(makeProbVec(trial(3,100000), findPluralityCount))
sum(makeProbVec(trial(3,100000), findPluralityCount))
sum(makeProbVec(trial(3,100000), findPluralityCount))
makeProbVec <- function(matrixy,func) {
vec <- func(matrixy)
prob <- c()
len <- length(vec)
summy <- sum(vec)
for (i in 1:len) {
prob[i] = vec[i]/summy
prob[i] = rnorm(1,mean = prob[i], sd = .02)
}
summy <- sum(prob)
prob = prob/summy
prob
}
sum(makeProbVec(trial(3,100000), findPluralityCount))
sum(makeProbVec(trial(3,100000), findPluralityCount))
makeProbVec(trial(3,100000), findPluralityCount))\
makeProbVec(trial(3,100000), findPluralityCount))
makeProbVec(trial(3,100000), findPluralityCount)
makeProbVec(trial(3,100000), findPluralityCount)
makeProbVec(trial(3,100000), findPluralityCount)
makeProbVec(trial(3,100000), findPluralityCount)
makeProbVec(trial(3,100000), findPluralityCount)
makeProbVec(trial(3,100000), findPluralityCount)
makeProbVec(trial(3,100000), findPluralityCount)
makeProbVec(trial(3,100000), findPluralityCount)
makeProbVec(trial(3,100000), findPluralityCount)
makeProbVec(trial(3,100000), findPluralityCount)
makeProbVec(trial(3,100000), findPluralityCount)
makeProbVec <- function(matrixy,func) {
vec <- func(matrixy)
prob <- c()
len <- length(vec)
summy <- sum(vec)
for (i in 1:len) {
prob[i] = vec[i]/summy
prob[i] = rnorm(1,mean = prob[i], sd = .05)
}
summy <- sum(prob)
prob = prob/summy
prob
}
makeProbVec(trial(3,100000), findPluralityCount)
makeProbVec(trial(3,100000), findPluralityCount)
makeProbVec(trial(3,100000), findPluralityCount)
makeProbVec(trial(3,100000), findPluralityCount)
makeProbVec(trial(3,100000), findPluralityCount)
makeProbVec(trial(3,100000), findPluralityCount)
makeProbVec(trial(3,100000), findPluralityCount)
makeProbVec(trial(3,100000), findPluralityCount)
makeProbVec(trial(3,100000), findPluralityCount)
makeProbVec(trial(3,100000), findPluralityCount)
makeProbVec(trial(3,100000), findPluralityCount)
makeProbVec(trial(3,100000), findPluralityCount)
makeProbVec(trial(3,100000), findPluralityCount)
max(replicate,max(makeProbVec(trial(3,100000))))
max(replicate,max(makeProbVec(trial(3,100000),findPluralityWinner)))
max(replicate(max(makeProbVec(trial(3,100000),findPluralityWinner))))
replicate(max(makeProbVec(trial(3,100000),findPluralityWinner)))
max(replicate(20,max(makeProbVec(trial(3,100000),findPluralityWinner))))
max(replicate(20,max(makeProbVec(trial(3,100000),findPluralityWinner))))
max(replicate(20,max(makeProbVec(trial(3,100000),findPluralityWinner))))
max(replicate(1,max(makeProbVec(trial(3,100000),findPluralityWinner))))
max(makeProbVec(trial(3,100000),findPluralityWinner))
makeProbVec(trial(3,100000),findPluralityWinner)
makeProbVec <- function(matrixy,func) {
vec <- func(matrixy)
prob <- c()
len <- length(vec)
summy <- sum(vec)
for (i in 1:len) {
prob[i] = vec[i]/summy
prob[i] = rnorm(1,mean = prob[i], sd = .05)
}
summy <- sum(prob)
prob = prob/summy
prob
}
makeProbVec(trial(3,100),1000)
makeProbVec(trial(3,100),findPluralityCount)
max(replicate(20,max(makeProbVec(trial(3,100000),findPluralityCount))))
max(replicate(50,max(makeProbVec(trial(3,100000),findPluralityCount))))
max(replicate(50,max(makeProbVec(trial(2,100000),findPluralityCount))))
max(replicate(50,max(makeProbVec(trial(2,100000),findPluralityCount))))
makeProbVec <- function(matrixy,func) {
vec <- func(matrixy)
prob <- c()
len <- length(vec)
summy <- sum(vec)
for (i in 1:len) {
prob[i] = vec[i]/summy
prob[i] = rnorm(1,mean = prob[i], sd = .1)
}
summy <- sum(prob)
prob = prob/summy
prob
}
max(replicate(50,max(makeProbVec(trial(2,100000),findPluralityCount))))
max(replicate(50,max(makeProbVec(trial(2,100000),findPluralityCount))))
b
### Function: findBordaCount
### Inputs: LISTY, a list of voters and their preferences
### Output: The Borda Counts for each candidate
findBordaCount <- function(matrixy) {
len = ncol(matrixy)
voteCount <- integer(len) #make a vector to keep track of vote totals for each candidate
numVoters <- nrow(matrixy)
for (i in 1:numVoters) {
matrixy[i,] = rank(matrixy[i,])
for (j in 1:len) {
voteCount[j] = (voteCount[j] - 1) + matrixy[i,j] #add the current voter's points
}
}
voteCount #return the vector containing each candidates point count
}
t <- trial(3,10)
t
findBordaCount(t)
rank(t)
t
findOptimalWinner <- function(matrixy) {
len = ncol(matrixy)
voteCount <- integer(len) #make a vector to keep track of vote totals for each candidate
numVoters <- nrow(matrixy)
for (i in 1:numVoters) {
for (j in 1:len) {
voteCount[j] = voteCount[j] + matrixy[i,j] #add the current voter's points
}
}
which.max(voteCount) #return the vector containing each candidates point count
}
isWinnerOptimal <- function(n,x,func)
{
t <- trial(n,x)
findPluralityWinner(t) == findOptimalWinner(t)
}
isWinnerOptimal(2,100,findPluralityWinner)
isWinnerOptimal(2,100,findPluralityWinner)
isWinnerOptimal(2,100,findPluralityWinner)
isWinnerOptimal(2,100,findPluralityWinner)
isWinnerOptimal(3,100,findPluralityWinner)
isWinnerOptimal(3,100,findPluralityWinner)
isWinnerOptimal(4,100,findPluralityWinner)
isWinnerOptimal(4,100,findPluralityWinner)
isWinnerOptimal(4,100,findPluralityWinner)
isWinnerOptimal(4,100,findPluralityWinner)
isWinnerOptimal(4,100,findPluralityWinner)
isWinnerOptimal(4,100,findPluralityWinner)
isWinnerOptimal(4,100,findPluralityWinner)
isWinnerOptimal(4,100,findPluralityWinner)
isWinnerOptimal(4,100,findPluralityWinner)
isWinnerOptimal(3,100,findPluralityWinner)
mean(t(replicate(100,isWinnerOptimal(3,100,findPluralityWinner))))
mean(t(replicate(100,isWinnerOptimal(3,100,findPluralityWinner))))
mean(t(replicate(100,isWinnerOptimal(3,100,findPluralityWinner))))
mean(t(replicate(100,isWinnerOptimal(3,100,findPluralityWinner))))
mean(t(replicate(100,isWinnerOptimal(3,100,findPluralityWinner))))
mean(t(replicate(100,isWinnerOptimal(3,100,findPluralityWinner))))
mean(t(replicate(100,isWinnerOptimal(3,100,findPluralityWinner))))
mean(t(replicate(100,isWinnerOptimal(3,100,findPluralityWinner))))
mean(t(replicate(100,isWinnerOptimal(3,100,findPluralityWinner))))
mean(t(replicate(10000,isWinnerOptimal(3,100,findPluralityWinner))))
mean(t(replicate(10000,isWinnerOptimal(3,100,findPluralityWinner))))
mean(t(replicate(10000,isWinnerOptimal(3,100,bordaCountWinner))))
mean(t(replicate(10000,isWinnerOptimal(3,100,bordaCountWinner))))
mean(t(replicate(10000,isWinnerOptimal(3,100,bordaCountWinner))))
mean(t(replicate(10000,isWinnerOptimal(3,100,bordaCountWinner))))
mean(t(replicate(10000,isWinnerOptimal(3,100,bordaCountWinner))))
isWinnerOptimal <- function(n,x,func)
{
t <- trial(n,x)
func(t) == findOptimalWinner(t)
}
mean(t(replicate(10000,isWinnerOptimal(3,100,bordaCountWinner))))
mean(t(replicate(10000,isWinnerOptimal(2,100,bordaCountWinner))))
mean(t(replicate(10000,isWinnerOptimal(3,100,findOptimalWinner))))
findScoreCount <- function(matrixy) {
len = ncol(matrixy)
scoreCount <- integer(len) #make a vector to keep track of score total
numVoters <- nrow(matrixy)
for (i in 1:numVoters) {
for (j in 1:len) {
scoreCount[j] = scoreCount[j] + matrixy[i,j] #add the current voter's utility
}
}
scoreCount #return the vector containing each candidates point count
}
findScoreWinner <- function(matrixy) {
which.max(findScoreCount(matrixy))
}
mean(t(replicate(10000,isWinnerOptimal(3,100,findScoreWinner))))
mean(t(replicate(10000,isWinnerOptimal(6,100,findScoreWinner))))
mean(t(replicate(1000,isWinnerOptimal(6,100,bordaCountWinner))))
mean(t(replicate(1000,isWinnerOptimal(6,100,bordaCountWinner))))
mean(t(replicate(1000,isWinnerOptimal(6,1000,bordaCountWinner))))
mean(t(replicate(1000,isWinnerOptimal(10,100,bordaCountWinner))))
mean(t(replicate(1000,isWinnerOptimal(20,100,bordaCountWinner))))
mean(t(replicate(1000,isWinnerOptimal(50,100,bordaCountWinner))))
mean(t(replicate(1000,isWinnerOptimal(100,100,bordaCountWinner))))
mean(t(replicate(1000,isWinnerOptimal(100,100,bordaCountWinner))))
mean(t(replicate(1000,isWinnerOptimal(75,100,bordaCountWinner))))
mean(t(replicate(1000,isWinnerOptimal(15,100,bordaCountWinner))))
mean(t(replicate(1000,isWinnerOptimal(5,100,bordaCountWinner))))
buildMatrix <- function(n,x) {
mat <- matrix(0, nrow = n, ncol = x + 1)
vec <- 10^(0:x)
for (i in 1:n) {
t = 1
for (j in vec) {
test <-  t(replicate(1000,isWinnerOptimal(i,j,bordaCountWinner)))
mat[i, t] = mean(test)
t = t + 1
}
}
mat
}
buildMatrix(10,3)
x <- buildMatrix(5,3)
x
xtable(x)
#---------------------------------------------------------------------------------------#
########      TO DO:                                                             ########
########            - define functions to simulate other voting systems          ########
########            - determine what to do in the case of a tie                  ########
########            - write function to find pairwise winner                     ########
########            - change storage of voters from lists of vectors to a matrix ########
########            - find a way to simulate strategic voting (teaming in Borda) ########
#---------------------------------------------------------------------------------------#
install.packages("xtable")
library("xtable")
xtable(x)
x <- buildMatrix(10,3)
x
xtable(x)
xtable(x, digits = 4)
buildMatrix <- function(n,x) {
mat <- matrix(0, nrow = n, ncol = x + 1)
vec <- 10^(0:x)
for (i in 1:n) {
t = 1
for (j in vec) {
test <-  t(replicate(1000,isWinnerOptimal(i,j,findPluralityWinner)))
mat[i, t] = mean(test)
t = t + 1
}
}
mat
}
x <- buildMatrix(5,3)
x
x <- buildMatrix(10,3)
x
xtable(x)
buildMatrix <- function(n,x) {
mat <- matrix(0, nrow = n, ncol = x + 1)
vec <- 10^(0:x)
for (i in 1:n) {
t = 1
for (j in vec) {
test <-  t(replicate(1000,isWinnerOptimal(i,j,bordaCountWinner)))
mat[i, t] = mean(test)
t = t + 1
}
}
mat
}
x <- buildMatrix(10,3)
x
xtable(x)
buildMatrix <- function(n,x) {
mat <- matrix(0, nrow = n, ncol = x + 1)
vec <- 10^(0:x)
for (i in 1:n) {
t = 1
for (j in vec) {
test <-  t(replicate(1000,isWinnerOptimal(i,j,findScoreWinner)))
mat[i, t] = mean(test)
t = t + 1
}
}
mat
}
x <- buildMatrix(10,3)
x <- buildMatrix(5,3)
x
xtable(x0)
xtable(x)
IRkernel::installspec()
install.packages("xtable")
install.packages("dplyr")
install.packages("tidyr")
install.packages("ggplot2")
install.packages("reshape2")
install.packages("xtable")
install.packages("dplyr")
install.packages("tidyr")
install.packages("ggplot2")
install.packages("reshape2")
install.packages('mdsr')
setwd("~/randomForestPresentation")
